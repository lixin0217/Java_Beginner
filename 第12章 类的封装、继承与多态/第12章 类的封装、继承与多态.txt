第12章 类的封装、继承与多态

类的封装、继承和多态是面向对象程序的三大特性。类的封装相当于一个黑匣子，放在黑匣子中的东西你什么也看不到。继承是类的一个重要特性，可以从一个简单的类继承出相对复杂高级的类，这样可使程序编写的工作量大大减轻。多态则可动态地对对象进行调用，使对象之间变得相对独立。本章讲解类的3大特性：封装、继承和多态。

12.1 面向对象的三大特点
面向对象有三大特点：封装性、继承性和多态性，它们是面向对象程序设计的灵魂所在

12.1.1 封装的含义
封装 (Encapsulation)是将描述某类事物的数据与处理这些数据的函数封装在一起，形成一个有机整体，称为类。类所具有的封装性可使程序模块具有良好的独立性与可维护性，这对大型程序的开发是特别重要的。类中的私有数据在类的外部不能直接使用，外部只能通过类的公共接口方法（函数）来处理类中的数据，从而使数据的安全性得到保证。封装的目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而仅需要通过外部接口，特定的访问权限来使用类的成员。

我们可用一个鸡蛋的三重构造来比拟一个对象：
属性(Attributes)好比蛋黄，它隐藏于中心，不能直接接触，它代表的对象的状态（State）。
行为(Behaviors)好比蛋白，它可以经由接口与外界交互而改变内部的属性值，并把这种改变通过接口呈现出来。
接口(Interface)好比蛋壳，它可以与外界直接接触。外部也只能通过公开的接口方法来改变对象内部的属性（数据）值，从而使类中数据的安全性得到保证。

12.1.2 继承的含义
对象（Object）是类（Class）的一个实例（Instance）。如果将对象比作房子，那么类就是房子的设计图纸。所以面向对象设计的重点是类的设计，而不是对象的设计。继承性是面向对象的第二大特征。继承（Inheritance）是面向对象程序设计中软件复用的关键技术，通过继承，可以进一步扩充新的特性，适应新的需求。这种可复用、可扩充技术在很大程度上降低了大型软件的开发难度，从而提高软件的开发效率。

当我们说某一个新类A继承某一既有类B时，表示这个新类A具有既有类B的所有成员，同时对既有类的成员做出修改，或是增加了新的成员。保持已有类的特性而构造新类的过程称为继承。在已有类的基础上新增自己的特性而产生新类的过程称为派生。我们把既有类称为基类(base class)、超类(super class)或者父类（parent class），而派生出的新类，称为派生类(derivedclass)或子类(subclass)。

继承可以使得子类自动具有父类的各种属性和方法，而不需要再次编写相同的代码，从而达到类的复用目的。这样，子类A可以对父类B的定义加以扩充，从而制定出一个不同于父类的定义，让子类具备新的特性。

继承的目的在于实现代码重用，对已有的成熟的功能，子类从父类执行“拿来主义”。而派生的目的则在于，当新的问题出现时，原有代码无法解决（或不能完全解决）时，需要对原有代码进行全部（或部分）改造。对于Java程序而言，设计孤立的类是比较容易的，难的是正确设计好的类层次结构，以达到代码高效重用的目的。

12.1.3 多态的含义
多态（Polymorphisn），从字面上理解，多态就是一种类型表现出多种状态。这也是人类思维方式的一种直接模拟，可以利用多态的特征，用统一的标识来完成这些功能。在Java中，多态性分为两类。

1. 方法多态性，体现在方法的重载与覆写上。
方法的重载是指同一个方法名称，根据其传入的参数类型、个数和顺序的不同，所调用的方法体也不同，即同一个方法名称在一个类中有不同的功能实现。方法的覆写是指父类之中的一个方法名称，在不同的子类有不同的功能实现，而后依据实例化子类的不同，同一个方法，可以完成不同的功能。

2. 对象多态性，体现在父、子对象之间的转型上。
在这个层面上，多态性是允许将父对象设置成为与一个或更多的子对象相等的技术，通过赋值之后，父对象就可以根据当前赋值给的不同子对象，以子对象的特性加以运作。多态意味着相同的（父类）信息发送给不同的（子）对象，每个子对象表现出不同的形态。

父、子对象之间的转型包括如下两种形式。
⑴ 向上转型（Upcast）（自动转型）：父类 父类对象 = 子类实例。
将子类对象赋值给父类对象，这样将子类对象自动转换为父类对象。这种转换方式是安全的。

⑵ 向下转型（Downcast）（强制转型）：子类 子类对象 = (子类) 父类对象。
将父类对象赋值给子类对象。这种转换方式是非安全的。

12.2 封装的实现
12.2.1 Java访问权限修饰符
在讲解Java面向对象三大特性之前有必要先介绍一下关于Java访问权限修饰符的知识。在Java中有四种访问权限：公有（public）、私有（private）、保护（protected）、默认（default）。但访问权限修饰符只有三种，因为默认访问权限没有访问权限修饰符。默认访问权限是包访问权限，即在没有任何修饰符的情况下定义的类，属性和方法在一个包内都是可访问的。

12.2.2 封装问题引例
【范例12-1】 类的封装性使用引例——一只品质不可控的猫（TestCat.Java）。

12.2.3 类的封装实例
之前所列举的程序都是用对象直接访问类中的属性，这在面向对象法则中是不允许的。所以为了避免程序中这种错误的发生，在一般的开发中往往要将类中的属性封装（private）。
【范例12-2】 类的封装实例——一只难以访问的猫。

程序设计人员一般在类的设计时，都会设计存或取这些属性的公共接口，这些接口的外在表现形式都是公有（public）方法。而在这些方法里，我们可以对存或取属性的操作，实施合理的检查，以达到保护属性数据的目的。通常，对属性值设置的方法被命名为SetXxx()，其中Xxx为任意有意义的名称，这类方法可统称为Setter方法.而对取属性值的方法通常被命名为GetYyy，其中Yyy为任意有意义的名称，这类方法可统称为Getter方法。

【范例12-3】 类私有属性的Setter和Getter方法——一只品质可控的猫（TestCat3.java）。
用private可以将属性封装起来，当然用private也可以封装方法.用private声明的属性或方法只能在其类的内部被调用，而不能在类的外部被调用。读者可以先暂时简单地理解为在类外部不能用对象去调用private声明的属性或方法。

【范例12-4】 方法的封装使用（TestCat4.Java）。
访问权限控制符是对类外而言的，而在同一类中，所有的类成员属性及方法都是相互可见的，也就是说，它们之间是可以相互访问的。

【范例12-5】 使用构造函数实现数据的封装（TestEncapsulation.Java）。
如果类中的某些数据在初始化后不想再被外界修改，则可以使用构造方法配合私有化的Setter 函数来实现该数据的封装

通过构造函数进行初始化类中的私有属性能够达到一定的封装效果，但是也不能过度相信这种封装，有些情况下即使这样做，私有属性也有可能被外界修改。从程序设计的角度来说，一般说来设计较好的程序的类中的属性都是需要封装的。此时要设置或取得属性值，则只能使用Setter和Getter方法，这是一个比较标准的做法。

12.2.4 封装问题的总结
在Java中，最基本的封装单元是类，类是基于面向对象思想编程语言的基础，程序员可以把具有相同业务性质的代码封装在一个类里，通过接口方法向外部代码提供服务，同时向外部代码屏蔽类里服务的具体实现方式。

数据封装的最重要的目的是在于要实现“信息隐藏（Information Hidding）”。在类中的“数据成员（属性）”或者“方法成员”，可以使用关键字“public”、”private”、”protected”来设置各成员的访问权限。

封装性是面向对象程序设计的原则之一。它规定对象应对外部环境隐藏它们的内部工作方式。良好的封装可以提高代码的模块化程度，它防止了对象之间不良的相互影响。使程序达到强内聚（许多功能尽量在类的内部独立完成，不让外面干预），弱耦合（提供给外部尽量少的方法调用）的最终目标。

12.2.5 实现封装应该注意的问题
实现封装是对外部而言的，我们总是要有选择地提供一些类似于setXxx()或者getYyy()的公有接口，以“可控”的方式来设置或读取类内部的属性值。有些属性值在初始化以后就不允许再进行修改，对这样的属性不设置setXxx()方法是明智的，或者这类设置Setter方法的访问权限设置为私有的，然后直接通过构造方法来调用这些方法，从而实现一次性的初始化。

【范例12-6】 返回引用数据时应该注意的问题（ReturnVariable.Java）。
在本例中需要注意的是当通过getIntArray()方法返回私有变量时，如果返回的是对该私有变量对象的引用，而不是副本。引用的含义在于，通过它直接能找到所操作对象在内存中的原始位置，则在该类的外部对其进行的修改会影响到内部。这类问题的解决办法是，如果返回值是对数据的引用则显式创建该数据的副本，然后返回该副本即可。


12.3 继承的实现
对于面向对象的程序而言，它的精华在于类的继承能以既有的类为基础，进而派生出新的类。通过这种方式，便能快速地开发出新的类，而不需编写相同的程序代码，这就是程序代码再利用的概念。

12.3.1 继承的基本概念
在Java中，通过继承可以简化类的定义，扩展类的功能。在Java中支持类的单继承和多层继承，但是不支持多继承，即一个类只能继承一个类而不能继承多个类。

实现继承的格式如下。
class 子类名 extends 父类
extends 是Java中的关键词。Java继承只能直接继承父类中的公有属性和公有方法，而隐含的(不可见的)继承了私有属性。

12.3.2 继承问题的引出
【范例12-7】 继承的引出（LeadInherit.Java）。

12.3.3 实现继承
【范例12-8】 类的继承演示程序（InheritDemo.Java）。
在Java中只允许单继承，而不允许多重继承，也就是说一个子类只能有一个父类。但在Java中允许多层继承。

12.3.4 继承的限制
限制1：Java之中不允许多重继承，但是却可以使用多层继承。
所谓的多重继承指的一个类同时继承多个父类的行为和特征功能。所谓多层继承，是指一个类B可以继承自某一个类A，而另外一个类C又继承自B，这样在继承层次上单项继承多个类.一般情况下，在我们所编写的代码时，多层继承的层数之中不宜超过三层。

限制2：从父类继承的私有成员，不能被子类直接使用。
子类在继承父类的时候会将父类之中的全部成员（包括属性及方法）继承下来，但是对于所有的非私有（private）成员属于显式继承，而对于所有的私有成员采用隐式继承（即对子类不可见）。子类无法直接操作这些私有属性，必须通过设置Setter和Getter方法间接操作。

限制3：子类在进行对象实例化时，从父类继承而来的数据成员需要先调用父类的构造方法来初始化，然后再用子类的构造方法来初始化本地的数据成员。在调用次序上，子类的构造方法要遵循“长辈优先”的原则，先调用父类的构造方法（生成父类对象），然后再调用子类的构造方法（生成子类对象）。也就是说，当实例化子类对象时，父类的对象会先“诞生”——这符合我们现实生活中对象存在的伦理。

限制4：被final修饰的类不能再被继承。
Java的继承性确实在某些时候可以提高程序的灵活性和代码的简洁度，但是有时我们定义了一个类但是不想让其被继承，即所有继承关系到此为止，如何实现这一目的呢？为此，Java提供了final关键字来实现这个功能。final在Java之中称为终结器。通过在类的前面添加final关键字便可以阻止该类被继承。

【范例12-9】 继承的限制（InheritRestrict.Java）。
用了final修饰，所以它不能被子类SubClass继承。

12.4 深度认识类的继承
12.4.1 子类对象的实例化过程
子类对象在实例化时,子类对象实例化会默认先调用父类中的无参构造函数,然后再调用子类构造方法。

【范例12-10】 子类对象的实例化（SubInstantProcess.Java）。
虽然第23行实例化的是子类的对象，其必然调用的是子类的无参构造方法，但是父类之中的无参构造方法也被默认调用了。由此可以证明子类对象在实例化时会默认先去调用父类中的无参构造方法，之后再调用本类中的相应构造方法。
在子类构造方法的首行相当于默认隐含了一个“super()”语句。如用户显式用super()去调用父类的构造方法，那么它必须出现在这个子类构造方法中的第1行语句。

12.4.2 super关键字的使用
在上面的程序中提到过super关键字，那super到底是什么？从英文本意来说，它表示“超级的”，从继承体系上，父类相对于子类是“超级的”，故此，有时候我们也称父类为超类(super-class)。super主要的功能是完成子类调用父类中的内容，也就是调用父类中的属性或方法。

如果子类继承了父类的数据成员，这时就需要调用父类的有参构造方法，来初始化来自于父类的数据成员，那如何做到这一点呢？这时就需要显式的调用父类中的有参构造方法super(参数1，参数2,…)。

【范例12-11】 super调用父类中的构造方法（SuperDemo.Java）。
调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有提供这种形式的构造方法，那么在编译的时候就会报错。

事实上，super关键字不仅可用于调用父类中的构造方法，也可用于调用父类中的属性或方法，如下面的格式所示。super.父类中的属性 ;
super.父类中的方法() ;

【范例12-12】 通过super调用父类的属性和方法（SuperDemo2.Java）。
super 是相对于继承而言的。super 代表的是当前类的父类，而this 这是代表当前类。如果父类的属性和方法的访问权限不是private（私有的），那么这些属性和方法在子类中是可视的，换句话说，这些属性和方法也可视为当前类所有的，那么用“this.”来访问也是理所当然的。如果子类对“父类”很“见外”，分得很清楚，那么就可用 “super.”访问来自于父类的属性和方法。

12.4.3 限制子类的访问
在有些时候，父类并不希望子类可以访问自己的类中全部的属性或方法，所以需要将一些属性与方法隐藏起来，不让子类去使用。为此可在声明属性或方法时加上“private”关键字，表示私有访问权限，即除了声明该属性或方法的所在类，其他外部的类均无权访问。

【范例12-13】 限制子类的访问（RestrictVisit.Java）。
在父类中，数据成员name和age的访问权限被设置为private，故子类即使继承了这个数据成员，也无法访问，它们在子类中均“不可视”,即使在属性成员前加上“super.”，也不会编译成功，这体现了类的封装性。
虽然父类的私有成员，外部（包括子类）无法访问，但是在父类内部，属性和方法彼此之间是不受访问权限约束的（自己怎么能和自己见外呢？），换句话说，父类的方法可以无障碍地访问父类的任何属性和访问。

【范例12-14】 子类访问父类的私有成员（RestrictVisit2.Java）。
为什么还设置为两个不同的方法呢？其实这是有差别的。构造方法Person()仅仅是在实例化对象时自动调用（如第37行），且仅能调用一次。但如果对象诞生之后，我们想修改属性的值，那该怎么办？这时就需要一个专门的设置属性值的方法——setVar()，它可以在对象诞生后调用任意多次（如第39行）。

12.5 覆写
“覆写（Override）”的概念与“重载（Overload）”有相似之处。所谓“重载”，即方法名称相同，方法的参数不同（包括类型不同、顺序不同和个数不同），也就是它们的方法签名（包括方法名+参数列表）不同。重载以表面看起来一样的方式——方法名相同，却通过传递不同形式的参数，来完成不同类型的工作，这样“一对多”的方式实现“静态多态”。

12.5.1 方法的覆写
当一个子类继承一个父类，如果子类中的方法与父类中的方法的名称、参数个数及类型且返回值类型等都完全一致时，就称子类中的这个方法覆写了父类中的方法。同理，如果子类中重复定义了父类中已有的属性，则称此子类中的属性覆写了父类中的属性。

【范例12-15】 子类覆写父类的实现（Override.Java）。
【范例12-16】 super调用父类的方法（Override2.Java）。

在完成方法的覆写时，读者应该需要注意如下几点。
⑴ 覆写的方法的返回值类型必须和被覆写的方法的返回值类型一致；
⑵ 被覆写的方法不能为static。
⑶ 被覆写的方法不能拥有比父类更为严格的访问控制权限。访问权限的大小通常依据下面的次序：私有（private）<默认（default）<公有（public）。如果父类的方法使用的是public定义，那么子类覆写时，权限只能是public，如果父类的方法是default权限，则子类覆写，方法可以使用default或者是public。也就是说，子类方法的访问权限一般要比父类大，至少相等。
如果父类之中定义的方法是private权限，那么对于子类而言根本就看不见父类的方法，因此在子类中定义的同名方法，其实相当于子类中增加了一个“全新”的方法，自然也就不存在所谓的覆写了。

12.5.2 属性的覆写
所谓的属性覆盖指的是子类定义了和父类之中名称相同的属性。
【范例12-17】 属性（数据成员）的覆写（OverrideData.java）。

从开发角度来说，为了满足类的封装型，类中的属性一般都需要使用private封装，一旦封装之后，子类压根就“看不见”父类的属性成员，子类定义的同名属性成员，其实就是一个“全新的”数据成员，所谓的覆写操作就完全没有意义了。

12.6 多态的实现
12.6.1 多态的基本概念
重载的表现形式就是调用一系列具有相同名称的方法，这些方法可根据传入参数的不同而得到不同的处理结果，这其实就是多态性的一种体现，这属于静态多态，即同一种接口，不同的实现方式。这种多态是在代码编译阶段就确定下来的。还有一种多态形式，在程序运行阶段才能体现出来，这种方式称为动态联编，也称为晚期联编(late bingding)。

【范例12-18】 了解多态的基本概念（Poly.Java）。

12.6.2 方法多态性
在Java中，方法的多态性体现在方法的重载。方法的多态即是通过传递不同的参数来令同一方法接口实现不同的功能。

【范例12-19】 对象多态性的使用（FuncPoly.Java）。

12.6.3 对象多态性
⑴ 向上转型。在【范例12-18】中，父类对象通过子类对象去实例化，实际上就是对象的向上转型。向上转型是不需要进行强制类型转换的，但是向上转型会丢失精度。
⑵ 向下转型。与向上转型对应的一个概念就是“向下转型”，所谓向下转型，也就是说父类的对象可以转换为子类对象，但是需要注意的是，这时则必须要进行强制的类型转换。

以上内容可以概括成下面的两句话。⑴ 向上转型可以自动完成。⑵ 向下转型必须进行强制类型转换。

【范例12-20】 使用多态（ObjectPoly.Java）。
简单来说，继承是子类使用父类的方法，而多态则是父类使用子类的方法。但更为确切来说，多态是父类使用被子类覆盖的同名方法，如果子类的方法是全新的，父类不存在同名的方法，则父类也不能使用子类自己独有的“个性化”方法。

即使实施向上转型，父类对象所能够看见的方法依然还是本类之中所定义的方法（即被子类覆盖的方法）。如果子类扩充了一些新方法的话，那么父类对象是无法找到的。
【范例12-21】 父类对象找不到子类的扩充方法（NewMethodTest.java）。

如果说现在非要去调用B类的getB()方法，那么就需要进行向下转型，即将父类对象变为子类实例，向下转型是需要采用强制转换的方式完成的。
【范例12-22】 实现向下转型（DownCastTest.java）。

“在形式上，类定义的对象只能看到自己所属类中的成员。” 虽然通过向上类型转换，子类对象可以给父类对象赋值，但父类对象也仅能看到在子类中被覆盖的成员（这些方法也在父类定义过了），父类对象无法看到子类的新扩充方法。

12.6.4 隐藏
隐藏（Hide）。被关键词static修饰的静态方法是不能被覆盖的， Java就是利用这一个特性达到隐藏的效果。

【范例12-23】 隐藏子类的成员。

12.7 高手点拨
1. 方法重载（Overload）和覆写（Override）区别（本题为常见的Java面试题）。
重载是指在相同类内定义名称相同但参数个数或类型或顺序不同的方法，而覆写是在子类当中定义名称、参数个数与类型均与父类相同的方法，用于覆写父类中的方法。在重载的关系之中，返回值类型可以不同，语法上没有错误，但是从实际的应用而言，建议，返回值类型相同。

2. this和super的区别（本题为常见的Java面试题）
由于this和super都可以调用构造方法，所以this()和super()语法不能同时出现，两者是二选一的关系。

3. final关键字的使用
final在Java之中称为终结器，在Java之中final可以修饰三类情况：修饰类、修饰方法及修饰变量。
⑴ 使用final修饰的类不能有子类（俗称太监类）。
⑵ 使用final定义的方法不能被子类所覆写。
⑶ 使用final定义的变量就成为了常量

12.8 实战练习






