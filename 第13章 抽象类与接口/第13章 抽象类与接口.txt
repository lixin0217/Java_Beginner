第13章 抽象类与接口

Java可以创建一种类专门用来当做父类，这种类称为“抽象类”。抽象类的作用有点类似“模板”，其目的是要设计者依据它的格式来修改并创建新的类。本章讲述抽象类的基本概念以及具有多继承特性的接口。

13.1 抽象类
在Java中可以创建一种类专门用来做父类，这种类称为“抽象类”。抽象类实际上也是一个类，只是与之前的普通类相比，内部新增了抽象方法。

13.1.1 抽象类的基本概念
抽象方法是只声明而未实现的方法，所有的抽象方法必须使用abstract关键字声明，包含抽象方法的类也必须使用abstractclass声明。

抽象类定义规则如下：
⑴ 抽象类和抽象方法都必须用abstract关键字来修饰；
⑵ 抽象类不能直接实例化，也就是不能直接用new关键字去产生对象；
⑶ 抽象类定义时抽象方法只需声明，而不需实现；
⑷ 含有抽象方法的类必须被声明为抽象类，抽象类的子类必须覆写所有的抽象方法后才能被实例化，否则这个子类还是个抽象类。

抽象类的定义就是比普通类多了一些抽象方法的定义而已。虽然定义了抽象类，但是抽象类却不能直接使用。
如果说一个类的对象可以被实例化，那么就表示这个对象可以调用类中的属性或者是方法，但是抽象类中存在抽象方法，而抽象方法没有方法体，没有方法体的方法无法使用。

对于抽象类的使用原则如下。抽象类必须有子类，子类使用extends继承抽象类，一个子类只能够继承一个抽象类；子类（如果不是抽象类）则必须覆写抽象类之中的全部抽象方法；如果要想实例化抽象类的对象，则可以使用子类进行对象的向上转型来完成。

【范例13-1】 抽象类的用法（代码AbstractClassDemo.java）。
【范例13-2】 抽象类中构造方法的定义使用（代码AbstractConstructor. java）。
【范例13-3】 验证static定义的内部抽象类（代码StaticInnerAbstractClass. java）。

抽象类的特征。
⑴ 抽象类中可以有构造方法。抽象类也可以像普通类一样，有构造方法、一般方法和属性，更重要的是还可以有一些抽象方法，需要子类去实现，而且在抽象类中声明构造方法后，在子类中必须明确调用。
⑵ 抽象类不能够使用final定义。使用final定义的类不能有子类，而抽象类使用的时候必须有子类，这是一个矛盾的问题，所以抽象类上不能出现final定义。
⑶ 在外部抽象类上无法使用static声明，但是内部抽象类却可以使用static定义，使用static定义的内部抽象类就表示一个外部类。
⑷ 抽象类之中可以没有抽象方法，但即便没有抽象方法的抽象类也不能够直接在外部通过关键字new实例化。

13.1.2 抽象类应用——模板设计模式
在使用抽象类时，可以将部分逻辑以具体方法和具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现，这就是模板方法模式。

【范例13-4】 模板设计模式（代码TemplateMethod.java）。

13.2 接口
接口（interface）是Java所提供的另一种重要技术，是一种特殊的类，它的结构和抽象类非常相似，也具有数据成员与抽象方法，但它与抽象类又有不同，并且Java 8中又添加了新特性。

13.2.1 接口的基本概念
接口里的数据成员必须初始化，且数据成员均为常量，常见的是全局变量。接口里的方法为abstract，也就是说，接口不能像抽象类一样定义一般的方法，需定义“抽象方法”。

Java8中为避免在接口中添加新方法后要修改所有实现类，允许定义默认方法，即default方法，也可以称为Defender方法，或者虚拟扩展方法（Virtual extension methods)。Default方法是指，在接口内部包含了一些默认的方法实现（也就是接口中可以包含方法体，这打破了Java之前版本对接口的语法限制），从而使得接口在进行扩展的时候，不会破坏与接口相关的实现类代码。

在Java中使用interface关键字来定义一个接口。

13.2.2 接口的使用原则
使用接口必须遵守如下原则。
接口必须有子类，子类依靠implements关键字可以同时实现多个接口；
接口的子类（如果不是抽象类）则必须覆写接口之中的全部抽象方法；
接口可以利用对象多态性，利用子类实现对象的实例化。

【范例13-5】 带default方法接口的实现（代码Interfacedefault.java）。
【范例13-6】 仅有default方法接口的使用（代码Interfacedefaultonly.java）。
【范例13-7】 子类继承多个接口的应用（代码InterfaceDemo.java）。
【范例13-8】 继承抽象类实现接口（代码ExtendsInterface.java）。
【范例13-9】 一个接口可继承多个接口（代码AbstractInterfaces.java）。

多继承中，如果说在一个子类即要实现接口又要继承抽象类，则应该采用先继承后实现的顺序完成。

13.2.3 接口的作用——制定标准
接口是标准，所谓的标准，指的是各方共同遵守的一个守则。只要操作标准统一了，所有的参与者才可以按照统一的规则操作。

【范例13-10】 接口制定标准（代码Interfacestandards.java）。

13.2.4 接口的作用——工厂设计模式（Factory）
在面向对象编程中, 最通常的方法是一个new操作符产生一个对象实例，new操作符就是用来构造对象实例的.如何能轻松地建立这么“复杂”的对象即操作中不需要粘贴复制呢?建立一个工厂来创建新的对象。

【范例13-11】 接口的作用（代码SimpleFactory.java）。
此例中发现在主类（客户端）之中直接让一个具体的子类和一个接口绑定在一起，那么如果要修改使用的子类，对于程序而言，就意味着要修改客户端。所以此时程序之中就出现了接口和子类的耦合问题，为解决这一问题，使用工厂模式。

【范例13-12】 工厂模式（代码Factory.java）。
此时的程序，客户端没有和具体的子类耦合在一起，这样一来，如果再有更多的Fruit接口子类出现，只需要修改Factory类即可，即：所有的接口对象都通过Factory类取得。在程序员自己开发的代码之中，只要是遇见了取得接口对象实例的操作，都应该采用工厂设计模式。

13.2.5 接口的作用——代理设计模式（Proxy）
代理模式：给某一对象提供代理对象,并由代理对象控制具体对象的引用。代理，指的就是一个角色代表另一个角色采取行动

这里产生了四个对象：客户、代理商、红酒厂商、代理商-红酒厂商（关系）。代理模式作用：为其他对象（红酒厂商）提供一种代理（代理商）以控制对这个对象（红酒厂商）的访问。代理对象可以在客户端（客户）和目标对象（红酒厂商）之间起到中介作用。

【范例13-13】 代理设计模式（代码Proxytest.java）。
代理设计模式的核心组成：一个接口有两个子类，一个子类负责真实的业务操作功能，另外一个子类负责完成与真实业务有关的操作。

13.3 抽象类和接口对比
abstract class和interface是Java语言中对于抽象类定义进行支持的两种机制，正是由于这两种机制的存在，才赋予了Java强大的面向对象能力。虽然两者在对于抽象类定义的支持方面具有很大的相似性，但也有各自不同的特点。

通过上面的系列分析，可以发现，抽象类和接口共同点。⑴ 都是抽象类型；⑵ 都可以有实现方法（以前接口不行）；⑶ 都可以不需要实现类或者继承者去实现所有方法。（以前不行，现在接口中默认方法不需要实现者实现）

抽象类和接口不同点。⑴ 抽象类不可以多重继承，接口可以（无论是多重类型继承还是多重行为继承）；⑵ 抽象类和接口所反映出的设计理念不同。其实抽象类表示的是"is-a"关系，接口表示的是"like-a"关系；⑶ 接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值；抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以重新赋值。

总体来说，抽象类和接口在很大程度上都是可以互相替换使用的，但就是由于抽象类本身具备单继承局限，所以当抽象类和接口全部都可以使用的时候优先考虑接口，因为接口没有单继承局限，并且在Java8中接口可以设定默认方法，在一定程度上避免代码重复，利于后期的维护。

接口、抽象类、类、对象的关系⑴ 基本类:也就是一般的类（一般所说的类就是基本类），是对象的模板，是属性和方法的集合。可以继承其他基本类、抽象类、实现接口。⑵ 抽象类：有抽象方法的类(抽象方法就是该方法必须由继承来实现，本身只定义，不实现)。抽象类可以有一个或多个抽象方法，它是基本类和接口类的过度。⑶ 接口：接口中的所有方法除默认方法（带方法体）外都是抽象方法，抽象方法本身只定义不实现，用来制定标准。
